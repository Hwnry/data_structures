<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>PA08_Lab08_Henry_Huffman: BSTree&lt; DataType, KeyType &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">PA08_Lab08_Henry_Huffman
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">BSTree&lt; DataType, KeyType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="BSTree" -->
<p><code>#include &lt;<a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a>&gt;</code></p>

<p><a href="class_b_s_tree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4513fc6697f5e51bff8e7c448b446c9e">BSTree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a6658391c178cb35858c9c465e1839fb0">BSTree</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree.html">BSTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac36b0b564aa3c411c239d730f506f448">operator=</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a968c51c539f4ae41357c78b6a60fea4c">~BSTree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab86b4cea496ee53076021126423d51fd">insert</a> (const DataType &amp;newDataItem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4359bfee390669b5adaf0380ef62b18d">retrieve</a> (const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a755549f7b88d0178a96ca84afd5e04cf">remove</a> (const KeyType &amp;deleteKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a7f08f48e6d1bbe3eb726856a947325e7">writeKeys</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a926822d08f3d0321603f9fafd2254b16">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a43768375369ca8fe641a86451997ad45">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac28277cacbf8ab33326473a419abf097">showStructure</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a3850adc6b8ae965ec11ec0e0567b6f7d">getHeight</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a880d98553153533d3c29504e8a272c7d">getCount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a92079e5301185f41eebe1c32c2357258">writeLessThan</a> (const KeyType &amp;searchKey) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a44b3002e3476eb410468a4b9aaaa73ef">showHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *p, int level) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#aa0723f656b301d41e727f385d2ba2972">assignmentHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;dest, <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ae6ebc1c4b8b1bba3f5e72f8d3700c79f">removeHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;src, const KeyType &amp;deleteKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab3d09c9969cce52974a4a65e00202061">insertHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;ptr, const DataType &amp;newDataItem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ad558bd869107eec627a5015e8361275b">retrieveHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *ptr, const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a55a1dafcd5a629264fe329a47ceabf4f">writeHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *ptr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a1ede33f8cbe9d1d94b479b477d95d016">clearHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a1e5f83d364cd403d5c548e46d2b665bf">countHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *ptr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a38df91c5e55a3b39f4590ee15f375f22">heightHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *ptr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a0e560eccf958fc8c7e0e63a1b9dcd6a9">lessHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *ptr, const KeyType &amp;searchKey) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a83534afce9094181ac031f9f596a8625">root</a></td></tr>
</table>
<h3>template&lt;typename DataType, class KeyType&gt;<br/>
 class BSTree&lt; DataType, KeyType &gt;</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4513fc6697f5e51bff8e7c448b446c9e"></a><!-- doxytag: member="BSTree::BSTree" ref="a4513fc6697f5e51bff8e7c448b446c9e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_b_s_tree.html">BSTree</a> constructor</p>
<p>This constructor sets the root pointer of the initialized tree to null</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there will be an uninitialized tree </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there will an initialized tree with the root pointer set to null </dd></dl>

</div>
</div>
<a class="anchor" id="a6658391c178cb35858c9c465e1839fb0"></a><!-- doxytag: member="BSTree::BSTree" ref="a6658391c178cb35858c9c465e1839fb0" args="(const BSTree&lt; DataType, KeyType &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_b_s_tree.html">BSTree</a> copy constructor</p>
<p>This constructor initializes a tree then copies the value of another tree. This process is completed by setting the root pointer to null, then calling the overloaded assigment operator to copy the values of a second tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- a binary tree that is to be copied to the current tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there will be one unitialized tree, and a tree that has not been copied </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there will be two trees with identical values </dd></dl>

</div>
</div>
<a class="anchor" id="a968c51c539f4ae41357c78b6a60fea4c"></a><!-- doxytag: member="BSTree::~BSTree" ref="a968c51c539f4ae41357c78b6a60fea4c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::~<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_b_s_tree.html">BSTree</a> deconstructor</p>
<p>This function clears all the data inside the current tree. It first checks to see if the tree is already empty. If it is not empty, it calls the clear function to deallocate all the memory allocated in the tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there may be a tree with memory allocated in it </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there not be any memory allocated to the current tree </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa0723f656b301d41e727f385d2ba2972"></a><!-- doxytag: member="BSTree::assignmentHelper" ref="aa0723f656b301d41e727f385d2ba2972" args="(BSTreeNode *&amp;dest, BSTreeNode *src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#aa0723f656b301d41e727f385d2ba2972">assignmentHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>assignmentHelper function</p>
<p>This function moves throughout the two trees and assigns the values from the src tree to the dest tree. This function is recursive, so it will call itself until the entire tree is copied. The base case for this call is if the src node is null.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- the node that will contain a copy of the src node's data. </td></tr>
    <tr><td class="paramname">src</td><td>- the node that contains the informationn that must be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>two pointers will be passed to this function. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the dest pointer will contain the src pointer's data and recursively call itself to copy the rest of the tree. If the src pointer was null, nothing occured. </dd></dl>

</div>
</div>
<a class="anchor" id="a926822d08f3d0321603f9fafd2254b16"></a><!-- doxytag: member="BSTree::clear" ref="a926822d08f3d0321603f9fafd2254b16" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a926822d08f3d0321603f9fafd2254b16">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clear function</p>
<p>This function will remove nodes from the BST using a postorder traversal.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there may or may not be data in current tree </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there will not be data in the current tree and root will be set to NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a1ede33f8cbe9d1d94b479b477d95d016"></a><!-- doxytag: member="BSTree::clearHelper" ref="a1ede33f8cbe9d1d94b479b477d95d016" args="(BSTreeNode *&amp;ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a1ede33f8cbe9d1d94b479b477d95d016">clearHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clearHelper function</p>
<p>This function checks for the children of each node, deletes them, then deletes the current node. This is done through a recursive call. The base case for this function is if the ptr is equivalent to null.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- a pointer with the address of the current node</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there may or may not be data in the current BST </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there will not be any data in the current BST and all pointers will be set to NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5f83d364cd403d5c548e46d2b665bf"></a><!-- doxytag: member="BSTree::countHelper" ref="a1e5f83d364cd403d5c548e46d2b665bf" args="(BSTreeNode *ptr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a1e5f83d364cd403d5c548e46d2b665bf">countHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>countHelper function</p>
<p>This function counts the total number of nodes with a recursive call. It stops calling itself if leaf is found, or the current node is null.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- current node in BST </td></tr>
    <tr><td class="paramname">total</td><td>- the number of nodes in BST</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int - returns the number of nodes found</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the number of nodes will be set to zero </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the total number of nodes found will be updated </dd></dl>

</div>
</div>
<a class="anchor" id="a880d98553153533d3c29504e8a272c7d"></a><!-- doxytag: member="BSTree::getCount" ref="a880d98553153533d3c29504e8a272c7d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a880d98553153533d3c29504e8a272c7d">getCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getCount function</p>
<p>Counts the total number of nodes in the current tree. This is done by checking to see if the current tree is empty. If it is not empty, it will return the countHelper, which recursively counts the number of nodes.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int - returns 0 if empty. Else, it will return the total number of nodes in current BST.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the total number of nodes will not be found </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the total number of nodes will be found </dd></dl>

</div>
</div>
<a class="anchor" id="a3850adc6b8ae965ec11ec0e0567b6f7d"></a><!-- doxytag: member="BSTree::getHeight" ref="a3850adc6b8ae965ec11ec0e0567b6f7d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a3850adc6b8ae965ec11ec0e0567b6f7d">getHeight</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getHeight function</p>
<p>This function counts the height of the current BST. First this function checks to see if its empty. If not empty, calls returns heightHelper. Else, it returns 0.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int - the height of the current tree</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the height of the tree will not be output </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the height of the tree will be output </dd></dl>

</div>
</div>
<a class="anchor" id="a38df91c5e55a3b39f4590ee15f375f22"></a><!-- doxytag: member="BSTree::heightHelper" ref="a38df91c5e55a3b39f4590ee15f375f22" args="(BSTreeNode *ptr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a38df91c5e55a3b39f4590ee15f375f22">heightHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>heightHelper function</p>
<p>this function recursively moves throughout the current tree. The base case is if the current pointer is null or has no children. Otherwise, the recursive call changes depending upon the number of children the node has.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- current node</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int - number of nodes involved in height</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there is an unknow number of nodes for the greatest height of the tree </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the height of the tree will be known </dd></dl>

</div>
</div>
<a class="anchor" id="ab86b4cea496ee53076021126423d51fd"></a><!-- doxytag: member="BSTree::insert" ref="ab86b4cea496ee53076021126423d51fd" args="(const DataType &amp;newDataItem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ab86b4cea496ee53076021126423d51fd">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert function</p>
<p>This function inserts the new data into the proper location of the BST. It first checks to see the current tree is empty. If it is empty, it simply sets the root equal to the new data. Otherwise, it calls the insertHelper to place the data in the correct location. If the same data item already exist, the new data item replaces it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newDataItem</td><td>- the newest data that must be added to the current binary tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>an existing tree will not have the new data item included in it </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the current tree will now have the new data item, if the new data item had the same key as an old data item, the the old data item will be replaced </dd></dl>

</div>
</div>
<a class="anchor" id="ab3d09c9969cce52974a4a65e00202061"></a><!-- doxytag: member="BSTree::insertHelper" ref="ab3d09c9969cce52974a4a65e00202061" args="(BSTreeNode *&amp;ptr, const DataType &amp;newDataItem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ab3d09c9969cce52974a4a65e00202061">insertHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insertHelper function</p>
<p>This function inserts the new dataItem into the correct location by checking the key and pointer. If the key is greater, it moves to the right of the current node. If the key is less, it moves to the left of the current node. If it is equivalent, it replaces the current data with the new data. If the pointer reaches a null location, the new data will be inserted into a new node at specified location.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- the current node that is to be compared </td></tr>
    <tr><td class="paramname">newDataItem</td><td>- the information that is to be inserted into the binary tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the dataItem will not be inserted into the current BST </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the dataItem will be inserted in the correct location of the current BST </dd></dl>

</div>
</div>
<a class="anchor" id="a43768375369ca8fe641a86451997ad45"></a><!-- doxytag: member="BSTree::isEmpty" ref="a43768375369ca8fe641a86451997ad45" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a43768375369ca8fe641a86451997ad45">isEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>isEmpty function</p>
<p>This function checks to see if there is any memory currently allocated in the BST</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool - if the root is not null it will return true. It will return false otherwise.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>it will not be know whether or not there is data </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>a boolean will be returned which determines whether or not there is data </dd></dl>

</div>
</div>
<a class="anchor" id="a0e560eccf958fc8c7e0e63a1b9dcd6a9"></a><!-- doxytag: member="BSTree::lessHelper" ref="a0e560eccf958fc8c7e0e63a1b9dcd6a9" args="(BSTreeNode *ptr, const KeyType &amp;searchKey) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a0e560eccf958fc8c7e0e63a1b9dcd6a9">lessHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>lessHelper function</p>
<p>This function outputs the keys with a smaller value than the searchKey specified. If the current pointer is not null, a comparison between the current node's key and the given search tree occurs. If current key is less than searchKey, the write helper is called to output the current node and all lesser nodes. Otherwise, a recursive call is used to check the nodes to the left of the current node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- current node that is needed for comparison </td></tr>
    <tr><td class="paramname">searchKey</td><td>- the specified key used to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>lesser keys, if any, will not be output </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>lesser keys found in current BST will be output </dd></dl>

</div>
</div>
<a class="anchor" id="ac36b0b564aa3c411c239d730f506f448"></a><!-- doxytag: member="BSTree::operator=" ref="ac36b0b564aa3c411c239d730f506f448" args="(const BSTree&lt; DataType, KeyType &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>overloaded assignement operator</p>
<p>This function takes two intialized trees and assigns the current tree the value of the other tree. This function checks to see if the same tree is assigned itself. If this is true, it returns the same tree; otherwise, it proceeds to clear the current tree and call the assignment helper. The assignment helper then recursively moves throughout the current and "other" tree to copy the values from the "other" tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- the binary tree that is to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(*this) - the current tree with the copied values</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>- there will be two initialized trees </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>there will be two trees with identical values in them. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a755549f7b88d0178a96ca84afd5e04cf"></a><!-- doxytag: member="BSTree::remove" ref="a755549f7b88d0178a96ca84afd5e04cf" args="(const KeyType &amp;deleteKey)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a755549f7b88d0178a96ca84afd5e04cf">remove</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove function</p>
<p>This function will remove a specified node. This function will return false if it is empty, or it will call the removeHelper to aide in the locating and removal of said node. To check whether or not the node is actually in the BST at all, the retrieve function is being used.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteKey</td><td>- the key of the matching</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool - returns true if the specified item was deleted, returns false otherwise</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there may or may not be a specified node that needs to be deleted from the current tree </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>there will not be a node that matches the item to be deleted in the current BST. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6ebc1c4b8b1bba3f5e72f8d3700c79f"></a><!-- doxytag: member="BSTree::removeHelper" ref="ae6ebc1c4b8b1bba3f5e72f8d3700c79f" args="(BSTreeNode *&amp;src, const KeyType &amp;deleteKey)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ae6ebc1c4b8b1bba3f5e72f8d3700c79f">removeHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeHelper function</p>
<p>This function removes the specified node from the BST. It relies on recursive calls throughout the current BST. It has several cases to account for the possible variations of children a node may have.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- a pointer that has the address to the current pointer </td></tr>
    <tr><td class="paramname">deleteKey</td><td>- the key that is used to identify the node that is needed to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool - a boolean statement that determines whether or not the node was removed</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>there may or may not be the node that needs to be deleted in the current BST </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the delete key will no longer be in the current BST </dd></dl>

</div>
</div>
<a class="anchor" id="a4359bfee390669b5adaf0380ef62b18d"></a><!-- doxytag: member="BSTree::retrieve" ref="a4359bfee390669b5adaf0380ef62b18d" args="(const KeyType &amp;searchKey, DataType &amp;searchDataItem) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a4359bfee390669b5adaf0380ef62b18d">retrieve</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retrieve function</p>
<p>This function checks to see if there is a data item that currently matches the search key. If the data item is found, it returns true and copies the data item to the search dataItem. Otherwise, it will return false. This function relies upon the retrieve helper function to find the data item.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchKey</td><td>- a unique id that corresponds the search dataItem </td></tr>
    <tr><td class="paramname">searchDataItem</td><td>- the dataItem that will hold the data of the node with the corresponding key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool - returns whether or not the search item was found</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>- data item may or may not be located in the current BST </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>- data Item will either be found or it will not be found </dd></dl>

</div>
</div>
<a class="anchor" id="ad558bd869107eec627a5015e8361275b"></a><!-- doxytag: member="BSTree::retrieveHelper" ref="ad558bd869107eec627a5015e8361275b" args="(BSTreeNode *ptr, const KeyType &amp;searchKey, DataType &amp;searchDataItem) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ad558bd869107eec627a5015e8361275b">retrieveHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retrieveHelper function</p>
<p>This function moves throughout the BST in search of a dataItem with the matching keys. If key is found, it returns true and updates the search data item. Otherwise, it will check to left and to the right of the current node. If the end of the tree is reached without a solution, false is returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- the current node that is going to be compared </td></tr>
    <tr><td class="paramname">searchKey</td><td>- the key that will determine if the current node matches, or if the search will continue to the left or to the right </td></tr>
    <tr><td class="paramname">searchDataItem</td><td>- the data at the matching node will be assigned to this parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool - returns whether or not the matching node was found</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the dataItem with the corresponding searchKey may or may not be in the BST </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the matching dataItem will be found, or it will not be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a44b3002e3476eb410468a4b9aaaa73ef"></a><!-- doxytag: member="BSTree::showHelper" ref="a44b3002e3476eb410468a4b9aaaa73ef" args="(BSTreeNode *p, int level) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a44b3002e3476eb410468a4b9aaaa73ef">showHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac28277cacbf8ab33326473a419abf097"></a><!-- doxytag: member="BSTree::showStructure" ref="ac28277cacbf8ab33326473a419abf097" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ac28277cacbf8ab33326473a419abf097">showStructure</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a55a1dafcd5a629264fe329a47ceabf4f"></a><!-- doxytag: member="BSTree::writeHelper" ref="a55a1dafcd5a629264fe329a47ceabf4f" args="(BSTreeNode *ptr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a55a1dafcd5a629264fe329a47ceabf4f">writeHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeHelper function</p>
<p>This function writes the keys of each dataItem in ascending order. This is done by checking if the current node is null. If it is not null, it will check to the left first to print out the lesser vales. Then it will output the current nodes. Then it will output the nodes to the right because they should be higher in value.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- current node that will check left, be output, then check right</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>no keys will be output </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>keys will be output in ascending order </dd></dl>

</div>
</div>
<a class="anchor" id="a7f08f48e6d1bbe3eb726856a947325e7"></a><!-- doxytag: member="BSTree::writeKeys" ref="a7f08f48e6d1bbe3eb726856a947325e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a7f08f48e6d1bbe3eb726856a947325e7">writeKeys</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeKeys function</p>
<p>This function outputs the keys of each dataItem. This is done in ascending order on one line, and it is seperated by one space between each key. This function calls the write helper function so it can recursively move througout the BST and output the keys in correct order</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the keys will remain hidden from the user </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the keys will be output to the screen </dd></dl>

</div>
</div>
<a class="anchor" id="a92079e5301185f41eebe1c32c2357258"></a><!-- doxytag: member="BSTree::writeLessThan" ref="a92079e5301185f41eebe1c32c2357258" args="(const KeyType &amp;searchKey) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a92079e5301185f41eebe1c32c2357258">writeLessThan</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeLessThan function</p>
<p>this function outputs all of the values in the current tree with the a key less than the specified searchKey. This functions check to see if current tree is empty, and class the lessHelper to aide in outputting the lesser values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchKey-</td><td>the key that must be compared to each node's key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>may or may not be values in BST less than searchKey </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>all values that are less than searchKey are output </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a83534afce9094181ac031f9f596a8625"></a><!-- doxytag: member="BSTree::root" ref="a83534afce9094181ac031f9f596a8625" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType, class KeyType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a>* <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a83534afce9094181ac031f9f596a8625">root</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a></li>
<li><a class="el" href="_b_s_tree_8cpp.html">BSTree.cpp</a></li>
<li><a class="el" href="show9_8cpp.html">show9.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 28 2014 21:46:51 for PA08_Lab08_Henry_Huffman by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
